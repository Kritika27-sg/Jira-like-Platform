{"ast":null,"code":"var _jsxFileName = \"/home/kritika/Documents/project/frontend/src/context/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// AuthContext.js\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(null);\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null); // { id, email, full_name, role }\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  useEffect(() => {\n    const checkAuthStatus = async () => {\n      const storedUser = localStorage.getItem('jira-user');\n      const storedToken = localStorage.getItem('jira-token');\n      if (storedUser && storedToken) {\n        try {\n          const parsedUser = JSON.parse(storedUser);\n          console.log('Loaded user from localStorage:', parsedUser);\n\n          // Verify token is still valid by checking with backend\n          const response = await fetch('http://localhost:8000/users/me', {\n            headers: {\n              'Authorization': `Bearer ${storedToken}`,\n              'Content-Type': 'application/json'\n            }\n          });\n          if (response.ok) {\n            const userData = await response.json();\n            // Use fresh data from backend, but fallback to stored data if needed\n            const finalUserData = {\n              ...parsedUser,\n              ...userData\n            };\n            setUser(finalUserData);\n            setIsAuthenticated(true);\n            // Update localStorage with fresh data\n            localStorage.setItem('jira-user', JSON.stringify(finalUserData));\n          } else {\n            // Token is invalid, clear stored data\n            console.log('Token invalid, clearing stored data');\n            localStorage.removeItem('jira-user');\n            localStorage.removeItem('jira-token');\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        } catch (error) {\n          console.error('Error verifying stored auth:', error);\n          // Clear potentially corrupted data\n          localStorage.removeItem('jira-user');\n          localStorage.removeItem('jira-token');\n          setUser(null);\n          setIsAuthenticated(false);\n        }\n      } else if (storedUser && !storedToken) {\n        // User data exists but no token - likely incomplete auth state\n        console.log('User data found but no token, clearing data');\n        localStorage.removeItem('jira-user');\n        setUser(null);\n        setIsAuthenticated(false);\n      }\n      setLoading(false);\n    };\n    checkAuthStatus();\n  }, []);\n  const login = userData => {\n    // userData MUST contain the role property, e.g., { id: ..., email: ..., full_name: ..., role: \"Admin\" }\n    setUser(userData);\n    setIsAuthenticated(true);\n    localStorage.setItem('jira-user', JSON.stringify(userData));\n    console.log('User logged in, stored to localStorage:', userData);\n  };\n  const logout = () => {\n    setUser(null);\n    setIsAuthenticated(false);\n    localStorage.removeItem('jira-user');\n    localStorage.removeItem('jira-token');\n    console.log('User logged out, cleared localStorage');\n  };\n  const signUp = async ({\n    name,\n    email,\n    password,\n    role\n  }) => {\n    try {\n      const response = await fetch('http://localhost:8000/auth/register', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          full_name: name.trim(),\n          email: email.trim(),\n          password,\n          role\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || errorData.message || 'Signup failed');\n      }\n      const data = await response.json();\n      console.log('User data after sign-up:', data.user);\n\n      // Don't auto-login after signup - let them login manually\n      // This is more secure and follows common UX patterns\n      return data;\n    } catch (error) {\n      console.error('Signup error:', error);\n      throw error;\n    }\n  };\n\n  // Helper function to update user data\n  const updateUser = updatedUserData => {\n    const newUserData = {\n      ...user,\n      ...updatedUserData\n    };\n    setUser(newUserData);\n    localStorage.setItem('jira-user', JSON.stringify(newUserData));\n    console.log('User data updated:', newUserData);\n  };\n\n  // Helper function to check if user has specific role\n  const hasRole = requiredRole => {\n    return (user === null || user === void 0 ? void 0 : user.role) === requiredRole;\n  };\n\n  // Helper function to check if user has any of the specified roles\n  const hasAnyRole = roles => {\n    return roles.includes(user === null || user === void 0 ? void 0 : user.role);\n  };\n  const value = {\n    user,\n    loading,\n    isAuthenticated,\n    login,\n    logout,\n    signUp,\n    updateUser,\n    hasRole,\n    hasAnyRole\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 147,\n    columnNumber: 5\n  }, this);\n};\n_s(AuthProvider, \"xBgiRagNfQVCfEr2dT2PptfN+TE=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","jsxDEV","_jsxDEV","AuthContext","AuthProvider","children","_s","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","checkAuthStatus","storedUser","localStorage","getItem","storedToken","parsedUser","JSON","parse","console","log","response","fetch","headers","ok","userData","json","finalUserData","setItem","stringify","removeItem","error","login","logout","signUp","name","email","password","role","method","body","full_name","trim","errorData","Error","detail","message","data","updateUser","updatedUserData","newUserData","hasRole","requiredRole","hasAnyRole","roles","includes","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","$RefreshReg$"],"sources":["/home/kritika/Documents/project/frontend/src/context/AuthContext.js"],"sourcesContent":["// AuthContext.js\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\nconst AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null); // { id, email, full_name, role }\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  useEffect(() => {\n    const checkAuthStatus = async () => {\n      const storedUser = localStorage.getItem('jira-user');\n      const storedToken = localStorage.getItem('jira-token');\n      \n      if (storedUser && storedToken) {\n        try {\n          const parsedUser = JSON.parse(storedUser);\n          console.log('Loaded user from localStorage:', parsedUser);\n          \n          // Verify token is still valid by checking with backend\n          const response = await fetch('http://localhost:8000/users/me', {\n            headers: {\n              'Authorization': `Bearer ${storedToken}`,\n              'Content-Type': 'application/json'\n            },\n          });\n\n          if (response.ok) {\n            const userData = await response.json();\n            // Use fresh data from backend, but fallback to stored data if needed\n            const finalUserData = {\n              ...parsedUser,\n              ...userData\n            };\n            setUser(finalUserData);\n            setIsAuthenticated(true);\n            // Update localStorage with fresh data\n            localStorage.setItem('jira-user', JSON.stringify(finalUserData));\n          } else {\n            // Token is invalid, clear stored data\n            console.log('Token invalid, clearing stored data');\n            localStorage.removeItem('jira-user');\n            localStorage.removeItem('jira-token');\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        } catch (error) {\n          console.error('Error verifying stored auth:', error);\n          // Clear potentially corrupted data\n          localStorage.removeItem('jira-user');\n          localStorage.removeItem('jira-token');\n          setUser(null);\n          setIsAuthenticated(false);\n        }\n      } else if (storedUser && !storedToken) {\n        // User data exists but no token - likely incomplete auth state\n        console.log('User data found but no token, clearing data');\n        localStorage.removeItem('jira-user');\n        setUser(null);\n        setIsAuthenticated(false);\n      }\n      \n      setLoading(false);\n    };\n\n    checkAuthStatus();\n  }, []);\n\n  const login = (userData) => {\n    // userData MUST contain the role property, e.g., { id: ..., email: ..., full_name: ..., role: \"Admin\" }\n    setUser(userData);\n    setIsAuthenticated(true);\n    localStorage.setItem('jira-user', JSON.stringify(userData));\n    console.log('User logged in, stored to localStorage:', userData);\n  };\n\n  const logout = () => {\n    setUser(null);\n    setIsAuthenticated(false);\n    localStorage.removeItem('jira-user');\n    localStorage.removeItem('jira-token');\n    console.log('User logged out, cleared localStorage');\n  };\n\n  const signUp = async ({ name, email, password, role }) => {\n    try {\n      const response = await fetch('http://localhost:8000/auth/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          full_name: name.trim(), \n          email: email.trim(), \n          password, \n          role \n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || errorData.message || 'Signup failed');\n      }\n\n      const data = await response.json();\n      console.log('User data after sign-up:', data.user);\n      \n      // Don't auto-login after signup - let them login manually\n      // This is more secure and follows common UX patterns\n      return data;\n    } catch (error) {\n      console.error('Signup error:', error);\n      throw error;\n    }\n  };\n\n  // Helper function to update user data\n  const updateUser = (updatedUserData) => {\n    const newUserData = { ...user, ...updatedUserData };\n    setUser(newUserData);\n    localStorage.setItem('jira-user', JSON.stringify(newUserData));\n    console.log('User data updated:', newUserData);\n  };\n\n  // Helper function to check if user has specific role\n  const hasRole = (requiredRole) => {\n    return user?.role === requiredRole;\n  };\n\n  // Helper function to check if user has any of the specified roles\n  const hasAnyRole = (roles) => {\n    return roles.includes(user?.role);\n  };\n\n  const value = {\n    user,\n    loading,\n    isAuthenticated,\n    login,\n    logout,\n    signUp,\n    updateUser,\n    hasRole,\n    hasAnyRole\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}